# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GraphPlotDialog
                                 A QGIS plugin
 Plots graphs on map
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-06-04
        git sha              : $Format:%H$
        copyright            : (C) 2023 by arka
        email                : arkaprava.mail@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

BEZIER_RES = 0.01
BEZIER_PTS = int(1 // 0.01)
MAX_STROKE_WIDTH = 0.5

import pandas as pd
import numpy as np

import os
import subprocess
from copy import deepcopy

import graphviz
import pydot

import winsound

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox, QTableWidgetItem, QSlider
import PyQt5.QtCore as QtCore
from qgis.PyQt.QtCore import QVariant
from qgis.core import QgsApplication, \
    QgsVectorLayer, QgsFeature, QgsGeometry, \
    QgsPoint, QgsPointXY, QgsLineString, \
    QgsProject, QgsField, QgsSymbol, \
    QgsGraduatedSymbolRenderer, \
    QgsLineSymbol, \
    QgsRendererRange, QgsVectorLayerEditUtils, \
    QgsPalLayerSettings, QgsTextFormat, QgsVectorLayerSimpleLabeling, QgsMarkerSymbol, QgsSimpleMarkerSymbolLayerBase, QgsSimpleMarkerSymbolLayer, QgsMarkerLineSymbolLayer, \
    QgsMapRendererParallelJob

from qgis.PyQt.QtGui import QColor, QFont, QBrush
from qgis.utils import iface
from qgis.gui import QgsMapCanvas


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'graph_plot_dialog_base.ui'))

localdir = os.path.join(os.getenv('APPDATA'), 'graph_plot')
if not os.path.exists(localdir):
    os.makedirs(localdir)

filename = os.path.join(localdir, '.log')

def write_log_message(message, tag, level):
    with open(filename, 'a') as logfile:
        logfile.write('{tag}({level}): {message}'.format(tag=tag, level=level, message=message))

QgsApplication.messageLog().messageReceived.connect(write_log_message)

neato_exe = "C:\\Program Files\\Graphviz\\bin\\neato.exe"


class GraphPlotDialog(QtWidgets.QDialog, FORM_CLASS):
    # TODO: fix mutual cooperation between edge controls
    #   - delete edges functionality
    #   - pick heaviest n edges
    #   - edge thresholding

    # TODO: fix button controls (active/disabled)

    _edges = []
    _selected_edge = None

    _EDITMODE = False
    _EDITED = False

    _THRESHOLD = 0
    _THRESHOLD_UNIT = 1000.0


    # Table colors
    _DELETED_BACKGROUND = QColor(255, 235, 156)
    _DELETED_FOREGOUND = QBrush(QColor(156, 101, 0))
                                 
    _FILTERED_BACKGROUND = QColor(255, 199, 206)
    _FILTERED_FOREGROUND = QBrush(QColor(156, 0, 6))

    _DEFAULT_BACKGROUND = None
    _DEFAULT_FOREGROUND = None

    _selected_cell_pos = None

    # SCREENSHOT functionality
    _SCREENSHOT_MIN_DIM = 1920


    def __init__(self, parent=None):
        """Constructor."""
        super(GraphPlotDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # easter egg
        # winsound.PlaySound(
        #     os.path.join(os.path.dirname(__file__), "music", "tb.wav"), 
        #     winsound.SND_ASYNC | winsound.SND_ALIAS | winsound.SND_LOOP | winsound.SND_NODEFAULT
        # )

        self.config_file_path = os.path.join(localdir, ".conf")

        # TODO: make labeled slider
        self.edge_thres_slider.setRange(0, self._THRESHOLD_UNIT)
        self.edge_thres_slider.setSingleStep(1)
        self.edge_thres_slider.setPageStep(1)
        self.edge_thres_slider.valueChanged.connect(lambda value: self.threshold_label.setText(f"{(value / self._THRESHOLD_UNIT):.3f}"))


        self.adj_csv_loader.clicked.connect(self._select_adj_file)
        self.coords_csv_loader.clicked.connect(self._select_coords_file)
        self.dot_file_loader.clicked.connect(self._select_dot_file)
        self.dot_file_saver.clicked.connect(self._select_save_file)
        self.load_edges_btn.clicked.connect(self._load_edges)
        self.load_vertices_btn.clicked.connect(self._load_vertices)
        self.load_graph_btn.clicked.connect(self.load_graph)
        self.save_graph_btn.clicked.connect(self.save_graph)
        self.plot_btn.clicked.connect(self.plot)
        self.commit_btn.clicked.connect(self._commit_edits)
        self.close_layers_btn.clicked.connect(self._remove_layers)
        self.del_edge_btn.clicked.connect(self._delete_edge)
        self.screenshot_btn.clicked.connect(lambda *args: self._take_screenshot('full'))
        self.adjacency_table.cellClicked.connect(self._table_cell_clicked)

        iface.layerTreeView().currentLayerChanged.connect(self._commit_edits)

        self.elem_config_map = {
            "ADJ_FILE": self.adj_file_path,
            "COORDS_FILE": self.coords_file_path,
            "DOT_FILE": self.dot_file_path,
            "SAVE_FILE": self.save_file_path,
            "CALC_EDGES": self.calculate_edges
        }

        # load saved input
        self._load_prev_input()

        # connect to input saver
        self.rejected.connect(self._save_input)
        self.rejected.connect(lambda *args: winsound.PlaySound(None, winsound.SND_ASYNC))

    def _save_input(self):
        try:
            with open(self.config_file_path, 'w') as f:
                l = list()

                for key, val in self.elem_config_map.items():
                    if key == 'CALC_EDGES':
                        l.append(f"{key}={'true' if val.isChecked() else 'false'}")
                    else:
                        l.append(f"{key}={val.text()}")

                f.write('\n'.join(l))
        except:
            pass

    def _load_prev_input(self):
        if os.path.exists(self.config_file_path):
            # load configurations from configfile
            try:
                with open(self.config_file_path) as f:
                    for line in f.readlines():
                        key, val = line.strip('\n').split("=")
                        elem = self.elem_config_map[key]
                        
                        if key == 'CALC_EDGES':
                            elem.setChecked(val == "true")
                        else:
                            elem.setText(val)
            except:
                self.logBox.append("Error: could not load from config file.")

    def _table_cell_clicked(self, row, col):
        self.log_box.append(f"{row}, {col} clicked")

        if np.isnan(self.adj.iloc[row, col]) or row == col:
            return

        self._selected_cell_pos = (row, col)

        # change delete button text based on whether already deleted edge
        flag = self.adj_mask.iloc[row, col]

        if flag:
            self.del_edge_btn.setText("DELETE EDGE")
        else:
            self.del_edge_btn.setText("REDRAW EDGE")

    def _remove_layers(self):
        try:
            # QgsProject.instance().removeAllMapLayers()
            self.layer_tree_root.removeChildNode(self.layer_group)
        except:
            pass
        else:
            self.log_box.append("removed all layers")
    
    def _select_adj_file(self):
        adj_file_path, _ = QFileDialog.getOpenFileName(self, "choose csv file", "", "*.csv")
        self.adj_file_path.setText(adj_file_path)

    def _select_coords_file(self):
        coords_file_path, _ = QFileDialog.getOpenFileName(self, "choose csv file", "", "*.csv")
        self.coords_file_path.setText(coords_file_path)

    def _select_dot_file(self):
        dot_file_path, _ = QFileDialog.getOpenFileName(self, "choose dot file", "", "*.dot")
        self.dot_file_path.setText(dot_file_path)

    def _select_save_file(self):
        save_file_path, _ = QFileDialog.getSaveFileName(self, "choose dot file", "", "*.dot")
        self.save_file_path.setText(save_file_path)

    def _write_table(self, df):
        df = df.astype(str)
        df = df.fillna('NAN')

        cols = df.columns
        rows = df.index

        self.log_box.append(f"loaded data: {df.shape[0]} rows x {df.shape[1]} columns")
        self.log_box.append(f"columns: {str(cols)}")
        self.log_box.append(f"rows: {str(rows)}")

        table = self.adjacency_table

        table.setRowCount(df.shape[0])
        table.setColumnCount(df.shape[1])
        table.setHorizontalHeaderLabels(cols)
        table.setVerticalHeaderLabels(rows)

        
        for i in range(df.shape[0]):
            for j in range(df.shape[1]):
                val = df.iloc[i, j]

                cell = QTableWidgetItem(val)
                cell.setFlags(QtCore.Qt.ItemIsEnabled)

                if not self._DEFAULT_BACKGROUND:
                    self._DEFAULT_BACKGROUND = cell.background()
                if not self._DEFAULT_FOREGROUND:
                    self._DEFAULT_FOREGROUND = cell.foreground()
                
                if not self.adj_mask.iloc[i, j]:
                    cell.setBackground(self._FILTERED_BACKGROUND)
                    cell.setForeground(self._FILTERED_FOREGROUND)

                table.setItem(i, j, cell)

        table.show()

    def _delete_edge(self):
        if self._selected_cell_pos is None:
            return
        
        row, col = self._selected_cell_pos
        cell = self.adjacency_table.item(row, col)
        flag = self.adj_mask.iloc[row, col]

        if flag:
            # to delete
            self.adj_mask.iloc[row, col] = False        
            cell.setBackground(self._DELETED_BACKGROUND)
            cell.setForeground(self._DELETED_FOREGOUND)
        else:
            # to redraw
            self.adj_mask.iloc[row, col] = True        
            cell.setBackground(self._DEFAULT_BACKGROUND)
            cell.setForeground(self._DEFAULT_FOREGROUND)
        
        self.plot()
        self._selected_cell_pos = None

    def _qgis_assert(self, statement):
        '''
            asserts statement and shows a error dialog on exception
        '''
        pass

    def _load_edges(self):
        # adj_file_path = 'C:/Users/arka/Documents/summer 23/transition_matrix.csv'
        # adj_file_path = 'C:/Users/arka/Documents/summer 23/transition_matrix - Copy.csv'
        
        adj_file_path = self.adj_file_path.text()

        if os.path.isfile(adj_file_path):
            # TODO: normalize adjacency matrix
            # TODO: add support for indices of all types (convert indices along both axes to string)
            # TODO: check that index and columns contain the same elements
            self.adj = pd.read_csv(adj_file_path, index_col=[0])

            self.adj.index = self.adj.index.map(str)
            self.adj.columns = self.adj.columns.astype(str)

            # create mask
            self.adj_mask = ~pd.isna(self.adj)

            # do not plot diagonals by default
            for i in range(self.adj.shape[0]):
                self.adj_mask.iloc[i, i] = False

            self._write_table(self.adj.copy(deep=True))

            # normalize
            self.adj = self.adj.div(self.adj.sum(axis=1), axis=0)

            # top edge slider
            count = self.adj.shape[0] * self.adj.shape[1]
            self.top_edge_slider.setRange(1, count)
            self.top_edge_slider.setSingleStep(1)
            self.top_edge_slider.setPageStep(1)

            self.top_edge_slider.setValue(count)
            self.top_edge_slider.repaint()

            self.top_edge_label.setText(str(count))

            self.top_edge_slider.valueChanged.connect(self._top_edge_slider_handler)

    def _top_edge_slider_handler(self, value):
        return
    
        self.top_edge_label.setText(str(value))

        adj_np = self.adj.to_numpy()
        adj_np = adj_np.ravel()

        indices = np.argpartition(adj_np, -value)[-value:]
        indices = [divmod(i, self.adj.shape[1]) for i in indices]

        for i, j in indices:
            self.adj_mask.iloc[i, j] &= True

    def _load_vertices(self):
        # coords_file_path = 'C:/Users/arka/Documents/summer 23/clusters.csv'
        coords_file_path = self.coords_file_path.text()

        if os.path.isfile(coords_file_path):
            self.clusters = pd.read_csv(coords_file_path, index_col=[0])

            self.minLng = self.clusters['lng'].min()
            self.minLat = self.clusters['lat'].min()

            self.maxLng = self.clusters['lng'].max()
            self.maxLat = self.clusters['lat'].max()


            self.scaleLng = 1 / (self.maxLng - self.minLng)
            self.scaleLat = 1 / (self.maxLat - self.minLat)

            self._coords_scale = max(self.scaleLng, self.scaleLat) * 10

    def load_graph(self):
        '''
            load data from dot file
        '''
        try:
            g = pydot.graph_from_dot_file(self.dot_file_path.text())[0]
        except Exception as ex:
            self.log_box.append(f"failed to load graph. {ex}")
        else:
            self.log_box.append(f"loaded graph from dot file")

        edges = []

        for edge in g.get_edge_list():
            source, destination = edge.get_source(), edge.get_destination()

            pos = edge.get_attributes()['pos']
            control_points = pd.DataFrame(
                [
                    [float(coord) for coord in coords.split(',')] 
                    for coords in pos.strip('"').split()
                ], 
                columns=['lng', 'lat']
            )

            control_points['lng'] = control_points['lng'] / self._coords_scale + self.minLng
            control_points['lat'] = control_points['lat'] / self._coords_scale + self.minLat

            pts = self._bezier_curve(control_points)

            edges.append({
                'from': source, 
                'to': destination, 
                'ctrl_pts': control_points,
                'path': pts,
                'weight': self.adj.loc[source, destination]
            })

        self._edges = edges

    def _bernstein_polynomial(self, t, pts):
        if pts.shape[0] == 4:
            return  pts[0] * ((1 - t) ** 3) + \
                    pts[1] * (3 * t * ((1 - t) ** 2)) + \
                    pts[2] * (3 * (1 - t) * (t ** 2)) + \
                    pts[3] * (t ** 3)
        
    def _bezier_curve(self, ctrl_pts, res=BEZIER_RES):
        # TODO: more adaptive (adaptive to second derivative of the curve) digitization of bezier curves
        ts = np.arange(0, 1 + res, res)

        pts = [ctrl_pts.apply(lambda pts: self._bernstein_polynomial(t, pts)) for t in ts]
        return pd.concat(pts, axis=1).T

    def _get_edges(self):
        self.log_box.append("calculating edges...")

        graph_attrs = {
            'overlap': 'voronoi',
            'sep': '0',
            'pad': '0', 
            'margin': '0',
            'notranslate': 'true'
        }
        graph_attrs_orig = {'splines': 'true', 'pad': '0', 'margin': '0', 'notranslate': 'true'}
        g = graphviz.Digraph('G', filename='graph', graph_attr=graph_attrs_orig)

        g.edge_attr = {'headclip': 'false', 'tailclip': 'false'}

        for cluster in self.clusters.index:
            lng = self.clusters.loc[cluster, 'lng']
            lat = self.clusters.loc[cluster, 'lat']

            lng = (lng - self.minLng) * self._coords_scale
            lat = (lat - self.minLat) * self._coords_scale

            
            g.node(str(cluster), pos=f"{lng},{lat}!", fixedsize='true', width='0.0', height='0.0', label='', penwidth="0.01")

        for i in self.adj.index:
            for j in self.adj.columns:
                if self.adj_mask.loc[i, j]:
                    g.edge(i, j, penwidth="0.01", arrowhead="none")

        g.save(os.path.join(localdir, 'graph'))

        # use neato to plot edges
        # subprocess.call(['runas', '/user:Administrator', 'neato qgis_sikkim -n -o "C:/Users/arka/Documents/summer 23/qgis_sikkim.dot"'])

        open(os.path.join(localdir, 'graph.dot'), 'w').close()

        command = f"\"{neato_exe}\" \"{os.path.join(localdir, 'graph')}\" -n -o \"{os.path.join(localdir, 'graph.dot')}\""
        # self.log_box.append(str(os.system(command)))

        try:
            subprocess.check_output(command, stderr=subprocess.STDOUT, shell=True)
        except Exception as ex:
            self.log_box.append(str(ex))


        try:
            g = pydot.graph_from_dot_file(os.path.join(localdir, 'graph.dot'))[0]
        except Exception as ex:
            self.log_box.append(str(ex))

        edges = []

        for edge in g.get_edge_list():
            source, destination = edge.get_source(), edge.get_destination()

            pos = edge.get_attributes()['pos']
            control_points = pd.DataFrame(
                [
                    [float(coord) for coord in coords.split(',')] 
                    for coords in pos.strip('"').split()
                ], 
                columns=['lng', 'lat']
            )

            control_points['lng'] = control_points['lng'] / self._coords_scale + self.minLng
            control_points['lat'] = control_points['lat'] / self._coords_scale + self.minLat

            pts = self._bezier_curve(control_points)


            edges.append({
                'from': source, 
                'to': destination, 
                'ctrl_pts': control_points,
                'path': pts,
                'weight': self.adj.loc[source, destination]
            })

        self._edges = edges

    def _draw_edge(self, edge, provider, attrs=True):
        source = edge['from']
        destination = edge['to']
        thickness = edge['weight']

        path = edge['path']
        path['point'] = path.apply(lambda p: QgsPoint(p['lng'], p['lat']), axis=1)

        seg = QgsFeature()
        geom = QgsLineString(path['point'].tolist())
        seg.setGeometry(geom)

        if attrs:
            seg.setAttributes([
                str(source),
                str(destination),
                float(thickness)
            ])

        _, edgeFeatures = provider.addFeatures([seg])

        edge['id'] = edgeFeatures[-1].id()

        # self.log_box.append(f"added edge feature {edgeFeatures[-1].id()}")

    def _get_symbol(self, layer_type='edge'):
        if layer_type == 'edge':
            return QgsSymbol.defaultSymbol(self.edgeLayer.geometryType()) 
        elif layer_type == 'arrow':
            # Base style.    
            line = QgsLineSymbol()    

            # Create an marker line.
            marker_line = QgsMarkerLineSymbolLayer()

            # Configure the marker.
            simple_marker = QgsSimpleMarkerSymbolLayer()
            simple_marker.setShape(QgsSimpleMarkerSymbolLayerBase.Triangle)
            simple_marker.setSize(2)
            simple_marker.setAngle(90)
            simple_marker.setFillColor(QColor.fromHsl(200, 255, 31))
            # simple_marker.setOutlineColor(QColor("transparent"))
            # simple_marker.setStrokeWidth(0)
            simple_marker.setStrokeStyle(0) # No line

            # The marker has its own symbol layer.
            marker = QgsMarkerSymbol()
            marker.changeSymbolLayer(0, simple_marker)

            # Add the layer to the marker layer.
            marker_line.setPlacement(QgsMarkerLineSymbolLayer.CentralPoint)
            marker_line.setSubSymbol(marker)

            # Finally replace the symbol layer in the base style.
            line.changeSymbolLayer(0, marker_line)

            return line

    def _get_renderer_range_list(self, layer_type='edge'):
        self.max_graph_weight = self.adj.max().max()
        self.min_graph_weight = self.adj.min().min()

        max_weight = max(self._edges, key=lambda d: d['weight'])['weight']
        min_weight = min(self._edges, key=lambda d: d['weight'])['weight']
        weight_range = max_weight - min_weight
        unit = weight_range / 10

        rangeList = []

        for i in np.arange(min_weight, max_weight, unit):
            symbol = self._get_symbol(layer_type)

            # symbol.setColor(QColor.fromHsl(200, 255, 255 - min(int(128 * (1 + (i - min_weight) / (weight_range))), 256) - 1))
            symbol.setColor(QColor.fromHsl(200, 255, min(max(int(128 * (max_weight - i) / weight_range) + 10, 0), 255)))

            if layer_type == 'edge':
                symbol.setWidth(0.15 + (1 - 0.15) * (i - min_weight) / (weight_range))

            range_ = QgsRendererRange(i, i + unit - 1e-10, symbol, f"category {i:.2f} - {(i + unit):.2f}")
            rangeList.append(range_)

        return rangeList

    def _set_edge_renderer(self):
        '''
            set graduated symbol renderer to render lines with different stroke widths
        '''
        if self.adj.nunique().sum() <= 1:
            return 
        
        rangeList = self._get_renderer_range_list(layer_type='edge')            

        renderer = QgsGraduatedSymbolRenderer('edges', rangeList) 

        myClassificationMethod = QgsApplication.classificationMethodRegistry().method("EqualInterval")
        renderer.setClassificationMethod(myClassificationMethod)

        renderer.setClassAttribute('weight')
        
        self.edgeLayer.setRenderer(renderer)
        self.edgeLayer.triggerRepaint()

    def _draw_edge_polygon(self, edge):
        source = edge['from']
        destination = edge['to']
        thickness = edge['weight']

        path = edge['path']
        path['point'] = path.apply(lambda p: QgsPointXY(p['lng'], p['lat']), axis=1)
        pts = path['point'].tolist()
        self.log_box.append(str(type(pts)))
        self.log_box.append(str(type(pts[0])))

        curve = QgsFeature()
        curve.setGeometry(QgsGeometry.fromPolygonXY([pts]))

        curve.setAttributes([
            str(source),
            str(destination),
            float(thickness)
        ])

        self.edgeProvider.addFeatures([curve]) 
        
    def _draw_edge_labels(self, opacity=100):
        self.edgeLayer.setLabelsEnabled(False)
        self.edgeLayer.triggerRepaint()

        # TODO: customise more
        layer_settings  = QgsPalLayerSettings()

        text_format = QgsTextFormat()
        text_format.setFont(QFont("Arial", 7))
        text_format.setColor(QColor.fromHsl(200, 255, 31, alpha=int(opacity * 2.55)))
        text_format.setSize(7)

        # buffer_settings = QgsTextBufferSettings()
        # buffer_settings.setEnabled(True)
        # buffer_settings.setSize(1)
        # buffer_settings.setColor(QColor("white"))

        # text_format.setBuffer(buffer_settings)

        layer_settings.setFormat(text_format)

        layer_settings.isExpression = True
        layer_settings.fieldName = 'concat(left("weight" * 100, 4), \'%\')'
        layer_settings.placement = QgsPalLayerSettings.Curved
        layer_settings.distance = 1.0

        layer_settings.enabled = True

        layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)

        self.edgeLayer.setLabelsEnabled(True)
        self.edgeLayer.setLabeling(layer_settings)
        self.edgeLayer.triggerRepaint()

    def _draw_arrow(self, edge):
        # TODO: draw arrow edge with the correct length corresponding to size of triangle marker

        path = edge['path']
        thickness = edge['weight']

        if 'point' not in path.columns:
            path['point'] = path.apply(lambda p: QgsPoint(p['lng'], p['lat']), axis=1)

        mid_pt = BEZIER_PTS // 2
        arrow_line = path['point'].iloc[mid_pt:mid_pt + 2].tolist()

        seg = QgsFeature()
        geom = QgsLineString(arrow_line)
        seg.setGeometry(geom)

        seg.setAttributes([
            float(thickness)
        ])

        self.arrowProvider.addFeatures([seg])

    def _set_arrow_renderer(self):
        # Add the style to the line layer.        
        # renderer = QgsSingleSymbolRenderer(line)
        rangeList = self._get_renderer_range_list(layer_type='arrow') 

        renderer = QgsGraduatedSymbolRenderer('arrows', rangeList) 

        myClassificationMethod = QgsApplication.classificationMethodRegistry().method("EqualInterval")
        renderer.setClassificationMethod(myClassificationMethod)

        renderer.setClassAttribute('weight')  
        # renderer.setSourceSymbol(line)  

        self.arrowLayer.setRenderer(renderer)
        self.arrowLayer.triggerRepaint()

    def plot(self):
        self._remove_layers()

        # TODO: replace startEditing...commitChanges with edit() [from qgis.core import edit]

        # get edge weight threshold
        self._THRESHOLD = self.edge_thres_slider.value() / self._THRESHOLD_UNIT

        self.log_box.append(f"{self._THRESHOLD}")

        # consider only weights with weight within [THRESHOLD, 1]
        self.adj_mask &= (self.adj >= self._THRESHOLD)

        # fetch edges
        if self.calculate_edges.isChecked():
            self._get_edges()

        self.layer_tree_root = QgsProject.instance().layerTreeRoot()
        self.layer_group = self.layer_tree_root.addGroup('graph_plot')

        # NODE LAYER
        self.nodeLayer = QgsVectorLayer("Point?crs=epsg:4326", "cluster markers", "memory")
        self.nodeProvider = self.nodeLayer.dataProvider()
        self.nodeLayer.startEditing()

        for _, row in self.clusters.iterrows():
            node = QgsFeature()
            node.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(row['lng'], row['lat'])))
            self.nodeProvider.addFeatures([node])

        self.log_box.append(f"added {len(self.clusters)} features")

        self.nodeLayer.commitChanges()
        QgsProject.instance().addMapLayer(self.nodeLayer, False)
        self.layer_group.addLayer(self.nodeLayer)

        # TO TAKE A SCREENSHOT
        self.nodeLayer.selectionChanged.connect(lambda *args: self._take_screenshot('selection', *args))

        # EDGE LAYER
        # TODO: convert to multilinestring
        self.edgeLayer = QgsVectorLayer('LineString?crs=epsg:4326', 'edges', 'memory')
        self.edgeProvider = self.edgeLayer.dataProvider()
        self.edgeLayer.startEditing()

        self.edgeProvider.addAttributes([
            QgsField('from', QVariant.String),
            QgsField('to', QVariant.String),
            QgsField('weight', QVariant.Double)
        ])

        self.log_box.append(str(QgsSymbol.defaultSymbol(self.edgeLayer.geometryType()).width()))

        for edge in self._edges:
            self._draw_edge(edge, self.edgeProvider)

        self._set_edge_renderer()

        self._draw_edge_labels()
        
        self.edgeLayer.commitChanges()
        QgsProject.instance().addMapLayer(self.edgeLayer, False)
        self.layer_group.addLayer(self.edgeLayer)

        # TO START EDITING
        self.edgeLayer.selectionChanged.connect(self._handle_edge_selection)

        # ARROW LAYER
        self.arrowLayer = QgsVectorLayer('LineString?crs=epsg:4326', 'arrow', 'memory')
        # self.arrowLayer.setFlags(QgsMapLayer.Private)
        self.arrowProvider = self.arrowLayer.dataProvider()
        self.arrowLayer.startEditing()

        self.arrowProvider.addAttributes([
            QgsField('weight', QVariant.Double)
        ])

        for edge in self._edges:
            self._draw_arrow(edge)

        self._set_arrow_renderer()

        self.arrowLayer.commitChanges()
        QgsProject.instance().addMapLayer(self.arrowLayer, False)
        self.layer_group.insertLayer(0, self.arrowLayer)
        
        iface.layerTreeView().setCurrentLayer(self.edgeLayer)

    def _take_screenshot(self, extent_mode, *args):
        # TODO: fix feature size issue

        print(*args)

        # create Qt mapCanvas widget
        canvas = QgsMapCanvas()
        canvas.setCanvasColor(QColor("white"))
        canvas.enableAntiAliasing(True)

        node_list = QgsProject.instance().layerTreeRoot().findLayers()
        visible_node_list = list(filter(lambda layer: layer.isVisible(), node_list))
        visible_layer_list = [l.layer() for l in visible_node_list]

        if len(visible_layer_list) == 0:
            self.log_box.append("no visible layers")
            return
        
        if extent_mode == 'full':
            extent = iface.mapCanvas().extent()
        elif extent_mode == 'selection':
            # W, S, E, N
            extent = self.nodeLayer.boundingBoxOfSelected()

        extent_lat, extent_lng = extent.height(), extent.width()

        self.log_box.append(f"taking screenshot of {extent}")

        # set extent of canvas as well as what layers you would like to display
        canvas.setExtent(extent)
        canvas.setLayers(visible_layer_list)
        canvas.refresh()

        # rendering my map canvas to tif image
        settings = canvas.mapSettings()
        settings.setLayers(visible_layer_list)

        # resize output image
        # size = QtCore.QSize()
        # if extent_lng < extent_lat:
        #     height, width = int(self._SCREENSHOT_MIN_DIM * extent_lat / extent_lng), self._SCREENSHOT_MIN_DIM
        # else:
        #     height, width = self._SCREENSHOT_MIN_DIM, int(self._SCREENSHOT_MIN_DIM * extent_lng / extent_lat)
        # size.setHeight(height)
        # size.setWidth(width)

        # settings.setOutputSize(size)

        # self.log_box.append(f"{size.height()} {size.width()} {extent_lat} {extent_lng}")

        job = QgsMapRendererParallelJob(settings)
        job.start()
        job.waitForFinished()
        image = job.renderedImage()

        path, ok = QFileDialog.getSaveFileName(iface.mainWindow(), "Save Screenshot", "", "Images (*.png *.jpg)");
        if ok:
            self.log_box.append(f"screenshot saved at: {path}")
        else:
            self.log_box.append("screenshot canceled")

        image.save(path)

    def _handle_edge_selection(self):
        selected_edges = self.edgeLayer.selectedFeatures()

        # find selected edge
        if len(selected_edges) > 0:
            feature = selected_edges[0]

            id = feature.id()

            self._selected_edge_index, self._selected_edge = list(filter(
                lambda edge: edge[1]['id'] == id, 
                enumerate(self._edges))
            )[0]

            self._selected_edge_id = self._selected_edge['id']

            self.log_box.append(f"selected edge: {self._selected_edge_id}")

            self._selected_edge = deepcopy(self._selected_edge)
            
            self._start_edit()

    def _set_layer_opacity(self, layer, opacity=100):
        try:
            layer.setLayerTransparency(100 - opacity)
        except:
            try:
                layer.setOpacity(opacity / 100.0)
            except:
                pass
            else:
                layer.triggerRepaint()
        else:
            layer.triggerRepaint()

    def _start_bezier_edit(self):
        # start editing
        self.bezierCtrlLayer.startEditing()
        self.bezierCurveLayer.startEditing()

        iface.layerTreeView().setCurrentLayer(self.bezierCtrlLayer)
        QgsProject.instance().setTopologicalEditing(True)

        # iface.actionVertexTool().trigger()
        iface.actionVertexToolActiveLayer().trigger()

    def _start_edit(self):
        # self.log_box.append(f"edit mode: {self._EDITMODE}")

        ctrl_pts = self._selected_edge['ctrl_pts']

        src = self._selected_edge['from']
        dest = self._selected_edge['to']

        self.log_box.append(f"editing edge {self._selected_edge_id} from: {src} -> {dest}")

        # reduce opacity of original layers
        self._set_layer_opacity(self.nodeLayer, 15)
        self._set_layer_opacity(self.edgeLayer, 15)
        self._set_layer_opacity(self.arrowLayer, 15)

        # erase the edge labels
        self.edgeLayer.setLabelsEnabled(False)
        self.edgeLayer.triggerRepaint()

        # TODO: move these layers to an edit node in the layertree

        # create bezier control point layer
        self.bezierCtrlLayer = QgsVectorLayer('Point?crs=epsg:4326', 'bezier control points', 'memory')
        # self.bezierCtrlLayer.setFlags(QgsMapLayer.Private) # no edits on a private layer
        self.bezierCtrlProvider = self.bezierCtrlLayer.dataProvider()
        self.bezierCtrlLayer.startEditing()

        # draw markers for intermediate bezier points
        for _, row in ctrl_pts.iloc[1:-1, :].iterrows():
            node = QgsFeature()
            node.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(row['lng'], row['lat'])))
            self.bezierCtrlProvider.addFeatures([node])
        
        self.bezierCtrlLayer.commitChanges()
        QgsProject.instance().addMapLayer(self.bezierCtrlLayer, False)
        self.layer_group.insertLayer(0, self.bezierCtrlLayer)

        # create bezier curve layer
        self.bezierCurveLayer = QgsVectorLayer('LineString?crs=epsg:4326', 'bezier curve', 'memory')
        # self.bezierCurveLayer.setFlags(QgsMapLayer.Private)
        self.bezierCurveProvider = self.bezierCurveLayer.dataProvider()
        self.bezierCurveLayer.startEditing()

        self._draw_edge(self._selected_edge, self.bezierCurveProvider, attrs=False)
        
        self.bezierCurveLayer.commitChanges()
        QgsProject.instance().addMapLayer(self.bezierCurveLayer, False)
        self.layer_group.insertLayer(0, self.bezierCurveLayer)

        # connect control point updated event to handler function
        if not self._EDITMODE:
            self.bezierCtrlLayer.geometryChanged.connect(self._control_point_updated)

        self._start_bezier_edit()

        self._EDITMODE = True

    def _control_point_updated(self, id, new_geom):
        self._EDITED = True

        ctrl_pts = self._selected_edge['ctrl_pts']

        orig_lng, orig_lat = ctrl_pts['lng'].iloc[id-1], ctrl_pts['lat'].iloc[id-1]
        new_lng, new_lat = new_geom.asPoint().x(), new_geom.asPoint().y()

        # check if anchor points using id
        # anchor_pts = [1, ctrl_pts.shape[0]]
        anchor_pts = []

        if id in anchor_pts:
            # undo moved marker
            # this causes geometry change to same layer
            # and triggers this function
            # solution: unlink handler before commiting changes and then link again


            # unlink handler and halt edit mode to protect from commits
            self.bezierCtrlLayer.geometryChanged.disconnect(self._control_point_updated)
            self._EDITMODE = False

            # throw warning
            QMessageBox.warning(self, "Error", "cannot move anchor vertex")

            # translate marker back to original coordinates
            utils = QgsVectorLayerEditUtils(self.bezierCtrlLayer)

            # del_lng = orig_lng - new_lng
            # del_lat = orig_lat - new_lat

            # self.log_box.append(f"{del_lng:.4f} {del_lat:.4f}")

            # utils.translateFeature(id, del_lng, del_lat)

            utils.moveVertex(orig_lng, orig_lat, id, 0)

            self.bezierCtrlLayer.commitChanges()

            self._start_bezier_edit()

            # relink handler and restart edit mode
            self.bezierCtrlLayer.geometryChanged.connect(self._control_point_updated)
            self._EDITMODE = True

            return


        # update control points
        ctrl_pts.loc[ctrl_pts.index[id], 'lng'] = new_lng
        ctrl_pts.loc[ctrl_pts.index[id], 'lat'] = new_lat

        pts = self._bezier_curve(ctrl_pts)

        # update edge points
        self._selected_edge = {
            **self._selected_edge,
            'ctrl_pts': ctrl_pts,
            'path': pts
        }

        # clear existing features
        self.bezierCurveLayer.deleteFeatures([feat.id() for feat in self.bezierCurveLayer.getFeatures()])

        # draw current edge
        self._draw_edge(self._selected_edge, self.bezierCurveProvider, attrs=False)

    def _commit_edits(self):
        # TODO: fix commit issue

        if not self._EDITMODE:
            return
        
        self._EDITED = False
        self._EDITMODE = False

        self.log_box.append(f"commiting update to edge: {self._selected_edge_id} among {len(self._edges)} edges")
        

        # re-plot original edge layer
        self.edgeLayer.startEditing()

        # Step 1: delete edited edge
        self.edgeLayer.deleteFeatures([self._selected_edge_id])

        # Step 2: redraw edge
        self._draw_edge(self._selected_edge, self.edgeProvider)

        # update edges
        self._edges[self._selected_edge_index] = self._selected_edge
        
        self.edgeLayer.commitChanges()

        # self.log_box.append("committed changes to edge layer")


        # re-plot original arrow layer
        self.arrowLayer.startEditing()

        # Step 1: delete edited arrow
        self.arrowLayer.deleteFeatures([self._selected_edge_id])

        # Step 2: redraw arrow
        self._draw_arrow(self._selected_edge)

        self.arrowLayer.commitChanges()

        # self.log_box.append("committed changes to arrow layer")


        # return opacity of original layers to normal
        self._set_layer_opacity(self.nodeLayer, 100)
        self._set_layer_opacity(self.edgeLayer, 100)
        self._set_layer_opacity(self.arrowLayer, 100)

        # redraw the edge labels
        self._draw_edge_labels(opacity=100)

        # set current layer to edge Layer
        # Note that this triggers commitChanges
        iface.layerTreeView().setCurrentLayer(self.edgeLayer)

        # remove bezier layers
        self.bezierCtrlLayer.geometryChanged.disconnect(self._control_point_updated)
        QgsProject.instance().removeMapLayers([self.bezierCtrlLayer.id(), self.bezierCurveLayer.id()])


        # garbage cleanup
        del self._selected_edge
        del self._selected_edge_id 
        # del self._selected_edge_index
 
        del self.bezierCtrlLayer
        del self.bezierCtrlProvider
        del self.bezierCurveLayer
        del self.bezierCurveProvider

    def save_graph(self):
        '''
            save data as dot file
        '''
        self.log_box.append("flushing data to graph file")

        output_path = self.save_file_path.text()

        graph_attrs_orig = {'splines': 'true', 'pad': '0', 'margin': '0', 'notranslate': 'true'}
        g = graphviz.Digraph('G', graph_attr=graph_attrs_orig)

        g.edge_attr = {'headclip': 'false', 'tailclip': 'false'}

        self.minLng = self.clusters['lng'].min()
        self.minLat = self.clusters['lat'].min()

        self.maxLng = self.clusters['lng'].max()
        self.maxLat = self.clusters['lat'].max()


        self.scaleLng = 1 / (self.maxLng - self.minLng)
        self.scaleLat = 1 / (self.maxLat - self.minLat)

        self._coords_scale = max(self.scaleLng, self.scaleLat) * 10

        for cluster in self.clusters.index:
            lng = self.clusters.loc[cluster, 'lng']
            lat = self.clusters.loc[cluster, 'lat']

            lng = (lng - self.minLng) * self._coords_scale
            lat = (lat - self.minLat) * self._coords_scale

            g.node(str(cluster), pos=f"{lng},{lat}!", fixedsize='true', width='0.0', height='0.0', label='', penwidth="0.01")

        for edge in self._edges:
            pos = []

            for _, row in edge['ctrl_pts'].iterrows():
                lng, lat = row['lng'], row['lat']

                lng = (lng - self.minLng) * self._coords_scale
                lat = (lat - self.minLat) * self._coords_scale

                pos.append(f"{lng},{lat}")

            pos = " ".join(pos)
            g.edge(edge['from'], edge['to'], penwidth="0.01", arrowhead="none", pos=pos)

        g.save(output_path)

        self.log_box.append("flushed data to graph file")
